/** --------------------------------------------------------
    Autor: Bruno César Ghislandi
    Hardware: WeMos Lolin ESP32 oLED
    Framework: Arduino IDE 2.1.0
    Curso: Engenharia de Computação
    Disciplina: PFC II
    -------------------------------------------------------- */

/*  Relação entre pinos da placa e GPIOs do ESP32

    GPIO    INPUT     OUTPUT    Notes
    0       Pulled Up OK¹     output PWM signal at boot
    1       TX pin    OK¹     debug outout at boot
    2       OK      OK
    3       OK¹     RX Pin    HIGH at boot
    4       OK      OK      oLED
    5       OK      OK      oLED
    6       X     X     connectec to SPI flash
    7       X     X     connectec to SPI flash
    8       X     X     connectec to SPI flash
    11      X     X     connectec to SPI flash
    12      OK¹     OK
    13      OK      OK
    14      OK      OK
    15      OK      OK      output PWM signal at boot
    16      OK      OK      output PWM signal at boot
    25      OK      OK
    26      OK      OK
    36      OK            input only/ADC0
    39      OK            input only/ADC3/NO_PULLUP
  */

/* Bibliotecas instaladas na IDE

  - DHT sensor library by Adafruit
  - Adafruit Unifield Sensor by Adafruit <info@adafruit.com>
  - Adafruit SSD1306 by Adafruit
  - Adafruit GFX Library by Adafruit
  - Adafruit BusIO by Adafruit
  */

/* Configurações Necessárias

  - Download e instalação do Driver CP210 disponível em:
  https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers?tab=downloads
  - Ir em "Arquivos > Preferências" e adicionar a URL
  https://dl.espressif.com/dl/package_esp32_index.json para poder usar os pacotes do ESP32
  - Ir em "Ferramentas > Placas > Gerenciador de Placas" e procurar por "ESP"
  e instalar o resultado retornado "esp32 by Espressif Systems"
  - Por fim, selecionar a placa, que seria a WEMOS LOLIN32. 
  */

/* Inclusão de Bibliotecas */
#include "DHT.h"
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Fonts/FreeSerif9pt7b.h>

/* Definições e Constantes */
#define VOLT 39   // Pino responsável pela leitura da bateria
#define COLD 2    // Pino responsável por acionar ou não o rele que controla a refrigeração
#define LED_R 12  // Pino responsável por controlar a cor Vermelha do LED RGB
#define LED_G 13  // Pino responsável por controlar a cor Verde do LED RGB
#define BUZZ 14   // Pino responsável por controlar o Buzzer
#define START 15  // Pino responsável pelo botão de liga/desliga

#define DHTPIN 16
#define DHTTYPE DHT11
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
bool state, start = 0;

/* Configuração do DHT11 */
DHT dht(DHTPIN, DHTTYPE);

/* Configuração do Display */
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

/* Logo da SMARTLAB no formatdo HEX */
static const uint8_t image_logo_hex[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xff, 0x01, 0xff, 0xc0, 0x7f, 0xf0, 0x00, 0xff, 0x80, 0x0f, 0xff, 0xc0, 0x1f, 0xff, 0xfc,
  0x03, 0xff, 0xc1, 0xff, 0xc0, 0x7f, 0xf0, 0x00, 0xff, 0x80, 0x0f, 0xff, 0xf8, 0x1f, 0xff, 0xfc,
  0x0f, 0xff, 0xc1, 0xff, 0xe0, 0x7f, 0xf0, 0x01, 0xff, 0xc0, 0x0f, 0xff, 0xfc, 0x1f, 0xff, 0xfc,
  0x1f, 0xff, 0xc1, 0xff, 0xe0, 0x7f, 0xf0, 0x01, 0xff, 0xc0, 0x0f, 0xff, 0xfe, 0x1f, 0xff, 0xfc,
  0x1f, 0xff, 0xc1, 0xff, 0xe0, 0xff, 0xf0, 0x01, 0xff, 0xc0, 0x0f, 0xff, 0xfe, 0x1f, 0xff, 0xfc,
  0x1f, 0xc1, 0xc1, 0xff, 0xe0, 0xff, 0xf0, 0x03, 0xff, 0xe0, 0x0f, 0xe1, 0xfe, 0x1f, 0xff, 0xfc,
  0x3f, 0xc0, 0x41, 0xff, 0xf0, 0xff, 0xf0, 0x03, 0xf7, 0xe0, 0x0f, 0xe0, 0xff, 0x00, 0x7f, 0x00,
  0x3f, 0xc0, 0x01, 0xfb, 0xf0, 0xf7, 0xf0, 0x03, 0xf7, 0xe0, 0x0f, 0xe0, 0xfe, 0x00, 0x7f, 0x00,
  0x1f, 0xf0, 0x01, 0xfb, 0xf1, 0xf7, 0xf0, 0x07, 0xf7, 0xf0, 0x0f, 0xe0, 0xfe, 0x00, 0x7f, 0x00,
  0x1f, 0xfc, 0x01, 0xfb, 0xf1, 0xf7, 0xf0, 0x07, 0xe7, 0xf0, 0x0f, 0xe1, 0xfe, 0x00, 0x7f, 0x00,
  0x1f, 0xff, 0x01, 0xfd, 0xf9, 0xf7, 0xf0, 0x07, 0xe3, 0xf0, 0x0f, 0xff, 0xfc, 0x00, 0x7f, 0x00,
  0x0f, 0xff, 0xc1, 0xfd, 0xf9, 0xe7, 0xf0, 0x0f, 0xe3, 0xf8, 0x0f, 0xff, 0xf8, 0x00, 0x7f, 0x00,
  0x07, 0xff, 0xc1, 0xfd, 0xfb, 0xe7, 0xf0, 0x0f, 0xe3, 0xf8, 0x0f, 0xff, 0xe0, 0x00, 0x7f, 0x00,
  0x01, 0xff, 0xe1, 0xfd, 0xfb, 0xe7, 0xf0, 0x0f, 0xc3, 0xf8, 0x0f, 0xff, 0xf0, 0x00, 0x7f, 0x00,
  0x00, 0x3f, 0xe1, 0xfc, 0xff, 0xe7, 0xf0, 0x1f, 0xff, 0xfc, 0x0f, 0xff, 0xf8, 0x00, 0x7f, 0x00,
  0x00, 0x1f, 0xe1, 0xfc, 0xff, 0xc7, 0xf0, 0x1f, 0xff, 0xfc, 0x0f, 0xe7, 0xfc, 0x00, 0x7f, 0x00,
  0x00, 0x0f, 0xe1, 0xfc, 0xff, 0xc7, 0xf0, 0x1f, 0xff, 0xfc, 0x0f, 0xe3, 0xfc, 0x00, 0x7f, 0x00,
  0x1c, 0x1f, 0xe1, 0xfc, 0xff, 0xc7, 0xf0, 0x3f, 0xff, 0xfe, 0x0f, 0xe1, 0xfe, 0x00, 0x7f, 0x00,
  0x1f, 0xff, 0xe1, 0xfc, 0x7f, 0xc7, 0xf0, 0x3f, 0xff, 0xfe, 0x0f, 0xe1, 0xfe, 0x00, 0x7f, 0x00,
  0x1f, 0xff, 0xc1, 0xfc, 0x7f, 0x87, 0xf0, 0x3f, 0x80, 0xfe, 0x0f, 0xe1, 0xfe, 0x00, 0x7f, 0x00,
  0x1f, 0xff, 0xc1, 0xfc, 0x7f, 0x87, 0xf0, 0x7f, 0x80, 0xff, 0x0f, 0xe0, 0xff, 0x00, 0x7f, 0x00,
  0x1f, 0xff, 0x01, 0xfc, 0x3f, 0x87, 0xf0, 0x7f, 0x00, 0xff, 0x0f, 0xe0, 0xff, 0x00, 0x7f, 0x00,
  0x07, 0xf8, 0x01, 0xfc, 0x3f, 0x87, 0xf0, 0x7f, 0x00, 0x7f, 0x0f, 0xe0, 0xff, 0x00, 0x7f, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x1f, 0xf0, 0x01, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x1f, 0xf0, 0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x3f, 0xf8, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x3f, 0xf8, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x3f, 0xf8, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x7f, 0xfc, 0x01, 0xfc, 0x3f, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x7e, 0xfc, 0x01, 0xfc, 0x1f, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x7e, 0xfc, 0x01, 0xfc, 0x1f, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0xfe, 0x01, 0xfc, 0x3f, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfc, 0xfe, 0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfc, 0x7e, 0x01, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xfc, 0x7f, 0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xfc, 0x7f, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xf8, 0x7f, 0x01, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x03, 0xff, 0xff, 0x81, 0xfc, 0x1f, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x03, 0xff, 0xff, 0x81, 0xfc, 0x0f, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x03, 0xff, 0xff, 0x81, 0xfc, 0x0f, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x07, 0xff, 0xff, 0xc1, 0xfc, 0x1f, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x07, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x07, 0xf0, 0x1f, 0xc1, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x0f, 0xf0, 0x1f, 0xe1, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x0f, 0xe0, 0x1f, 0xe1, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x0f, 0xe0, 0x0f, 0xe1, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Protótipos de Funções */
void vTaskActionRead(void *pvParameters);
void vTaskDataRead(void *pvParameters);
void vTaskActionControl(void *pvParameters);
void vTaskDisplay(void *pvParameters);

/* Variáveis Globais */
QueueHandle_t xF1, xF2, xF3, xF4, xF5;
TaskHandle_t task1Handle = NULL;
TaskHandle_t task2Handle = NULL;
TaskHandle_t task3Handle = NULL;
TaskHandle_t task4Handle = NULL;
SemaphoreHandle_t xSemaphore;

void setup() {
  /* Iniciando o Sensor DHT11 */
  dht.begin();

  /* Definindo como entrada e saída as constantes */
  pinMode(VOLT, INPUT);
  pinMode(COLD, OUTPUT);
  pinMode(LED_R, OUTPUT);
  pinMode(LED_G, OUTPUT);
  pinMode(BUZZ, OUTPUT);
  pinMode(START, INPUT_PULLUP);

  /* Definindo o estado inicial das constantes */
  digitalWrite(COLD, LOW);
  digitalWrite(LED_R, LOW);
  digitalWrite(LED_G, LOW);
  digitalWrite(BUZZ, LOW);

  /* Criação das filas de informações */
  xF1 = xQueueCreate(1, sizeof(float));
  if (xF1 == NULL) {
    Serial.println("Nao foi possível criar a fila xF1");
    while (1)
      ;
  }
  xF2 = xQueueCreate(1, sizeof(float));
  if (xF2 == NULL) {
    Serial.println("Nao foi possível criar a fila xF2");
    while (1)
      ;
  }
  xF3 = xQueueCreate(1, sizeof(float));
  if (xF3 == NULL) {
    Serial.println("Nao foi possível criar a fila xF3");
    while (1)
      ;
  }
  xF4 = xQueueCreate(1, sizeof(float));
  if (xF4 == NULL) {
    Serial.println("Nao foi possível criar a fila xF4");
    while (1)
      ;
  }
  xF5 = xQueueCreate(1, sizeof(float));
  if (xF5 == NULL) {
    Serial.println("Nao foi possível criar a fila xF5");
    while (1)
      ;
  }

  /* Definição da base das funções */
  BaseType_t xOUT;

  /* Criação do método de gerenciamento via semáforos */
  xSemaphore = xSemaphoreCreateBinary();

  /* Criação e configuração das funções */
  xOUT = xTaskCreatePinnedToCore(vTaskActionRead, "Task1", configMINIMAL_STACK_SIZE + 1024, NULL, 4, &task1Handle, APP_CPU_NUM);
  if (xOUT == pdFAIL) {
    Serial.println("Não foi possível criar a Task 1");
    while (1)
      ;
  }
  xOUT = xTaskCreatePinnedToCore(vTaskDataRead, "Task2", configMINIMAL_STACK_SIZE + 1024, NULL, 3, &task2Handle, PRO_CPU_NUM);
  if (xOUT == pdFAIL) {
    Serial.println("Não foi possível criar a Task 2");
    while (1)
      ;
  }
  xOUT = xTaskCreatePinnedToCore(vTaskActionControl, "Task3", configMINIMAL_STACK_SIZE + 1024, NULL, 2, &task3Handle, APP_CPU_NUM);
  if (xOUT == pdFAIL) {
    Serial.println("Não foi possível criar a Task 3");
    while (1)
      ;
  }
  xOUT = xTaskCreatePinnedToCore(vTaskDisplay, "Task4", configMINIMAL_STACK_SIZE + 1024, NULL, 1, &task4Handle, PRO_CPU_NUM);
  if (xOUT == pdFAIL) {
    Serial.println("Não foi possível criar a Task 4");
    while (1)
      ;
  }
  Wire.begin(5, 4);
}

void loop() {
}

/* Função que controla quando o refrigerador deve estar ligado a leitura de sua bateria */
void vTaskActionRead(void *pvParameters) {
  float received, voltage, percentage = 0;
  bool atual, anterior = 1;
  while (1) {
    xQueueReceive(xF4, &received, pdMS_TO_TICKS(50));
    voltage = analogRead(VOLT);
    percentage = map(voltage, 2200, 4095, 0, 100);
    xQueueSend(xF3, &percentage, pdMS_TO_TICKS(50));
    xQueueSend(xF5, &percentage, pdMS_TO_TICKS(50));
    vTaskDelay(pdMS_TO_TICKS(50));
    atual = digitalRead(START);
    if (atual != anterior) {
      if (atual == 0) {
        state = !state;
        digitalWrite(BUZZ, HIGH);
        vTaskDelay(pdMS_TO_TICKS(200));
        digitalWrite(BUZZ, LOW);
      }
    }
    anterior = atual;

    if (state == 1 && received >= 8 && start == 0) {
      digitalWrite(COLD, LOW);
    }
    else {
      digitalWrite(COLD, HIGH);
    }
  }
}

/* Função que realiza a leitura da temperatura e umidade fornecida pelo DHT11 */
void vTaskDataRead(void *pvParameters) {
  float temperature, humidity;
  while (1) {
    temperature = dht.readTemperature();
    xQueueSend(xF1, &temperature, pdMS_TO_TICKS(50));
    xQueueSend(xF4, &temperature, pdMS_TO_TICKS(50));

    humidity = dht.readHumidity();
    xQueueSend(xF2, &humidity, pdMS_TO_TICKS(50));
    vTaskDelay(pdMS_TO_TICKS(2000));
  }
}

/* Função responsável pelo gerenciamento de lógica, informações luminosas e sonoras */
void vTaskActionControl(void *pvParameters) {
  float received = 0;
  while (1) {
    xSemaphoreTake(xSemaphore, 500);
    xQueueReceive(xF5, &received, pdMS_TO_TICKS(50));
    if (received <= 15 && start == 0 && state == 1) {
      for(byte i = 0;i<=3;i++) {
          static bool stateBz = 1;
          digitalWrite(BUZZ, stateBz);
          vTaskDelay(pdMS_TO_TICKS(200));
          stateBz = !stateBz;
      }
    }
    if (received <= 5 && start == 0 && state == 1) {
      start = 1;
    }
    else if (received <= 85 && start == 1 && state == 1) {
      digitalWrite(LED_R, HIGH);
    }
    else if (received >= 85 && start == 1 && state == 1) {
      start = 0;
      digitalWrite(LED_R, LOW);
    }
    else if (received >= 35 && start == 0 && state == 1) {
      digitalWrite(LED_R, LOW);
      digitalWrite(LED_G, HIGH);
    }
    else if (received < 35 && start == 0 && state == 1) {
      digitalWrite(LED_G, LOW);
      for(byte i = 0;i<=3;i++) {
          static bool ledR = 1;
          digitalWrite(LED_R, ledR);
          vTaskDelay(pdMS_TO_TICKS(200));
          ledR = !ledR;
      }
      vTaskDelay(pdMS_TO_TICKS(1000));
    }
    else {
      digitalWrite(LED_G, LOW);
      digitalWrite(LED_R, LOW);
    }
  }
}

/* Função responsável por enviar as informações ao display */
void vTaskDisplay(void *pvParameters) {
  float received, received2, received3 = 0;
  bool displayon = 0;
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C, false, false);
  display.clearDisplay();
  display.display();
  display.setTextSize(1);
  display.setFont(&FreeSerif9pt7b);
  display.setTextColor(SSD1306_WHITE);
  vTaskDelay(pdMS_TO_TICKS(200));
  while (1) {
    xSemaphoreTake(xSemaphore, 500);
    xQueueReceive(xF1, &received, pdMS_TO_TICKS(50));
    xQueueReceive(xF2, &received2, pdMS_TO_TICKS(50));
    xQueueReceive(xF3, &received3, pdMS_TO_TICKS(50));
    if (state == 1 && displayon == 0) {
      display.clearDisplay();
      display.drawBitmap(0, 0, image_logo_hex, 128, 64, 1);
      display.display();
      vTaskDelay(pdMS_TO_TICKS(2000));
      displayon = !displayon;
    }
    else if (state == 1 && displayon == 1) {
      display.clearDisplay();
      byte boxWidth = 125; // Largura do quadrado
      byte boxHeight = 60; // Altura do quadrado
      byte boxX = (display.width() - boxWidth) / 2; // Posição X do quadrado (centralizado horizontalmente)
      byte boxY = (display.height() - boxHeight) / 2; // Posição Y do quadrado (centralizado verticalmente)
      byte textPaddingX = 2; // Espaçamento horizontal interno do texto em relação às bordas do quadrado
      byte textPaddingY = 15; // Espaçamento vertical interno do texto em relação às bordas do quadrado

      display.drawRect(boxX, boxY, boxWidth, boxHeight, SSD1306_WHITE);
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setTextWrap(false);
      display.setCursor(boxX + textPaddingX, boxY + textPaddingY);
      display.println("Temp. " + String(received) + " C");
      display.setCursor(boxX + textPaddingX, boxY + boxHeight / 3 + textPaddingY);
      display.println("Umid. " + String(received2) + " %");
      display.setCursor(boxX + textPaddingX, boxY + (boxHeight / 3) * 2 + textPaddingY);
      display.println("Bateria: " + String(received3) + " %");
      display.display();
    }
    else {
      display.clearDisplay();
      display.display();
      displayon = 0;
    }
    vTaskDelay(pdMS_TO_TICKS(200));
  }
}